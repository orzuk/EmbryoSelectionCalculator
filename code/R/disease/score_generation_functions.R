#### FUNCTIONS #####

# generates a covariance matrix given a correlation matrix and list of variances
generate_Sigma <- function(variances, correlation_matrix) {
  
  # Ensure that the number of variances = the number of rows = the number of cols of the matrix  
  if(nrow(correlation_matrix) != length(variances)) {
    stop("Error: Dimensions differ. Does the number of variances equal the dimension of the correlation matrix?")
  }
  M <- nrow(correlation_matrix)
  Sigma <- matrix(nrow = M, ncol = M)
  diag(Sigma) <- variances
  for (i in 1:M) { # i.e., for i:M, the number of diseases
    for (j in 1:M) {
      if(i != j) {
        Sigma[i,j] <- correlation_matrix[i,j] * sqrt(variances[i] * variances[j])
      }
    }
  }
  return(Sigma)
}


## Generates the 4 matrices needed for running a simulation
generate_matrices_for_sim <- function(cor, pgs, h2, N_embryos){
  
  # Generate Sigma
  Sigma <- generate_Sigma(pgs, cor)
  M <- nrow(Sigma)
  missing_heritability <- h2-pgs
  
  # Generate Sigma_G
  Sigma_G <- generate_Sigma(missing_heritability, cor)
  
  # Generate error matrix and kinship matrix
  E_Matrix <- matrix(nrow = M, ncol = M, 0)
  diag(E_Matrix) <- 1-h2
  
  # Generate Kinship Matrix
  Kin_Matrix <- matrix(nrow = N_embryos, ncol = N_embryos, 0.5)
  diag(Kin_Matrix) <- 1
  
  matrices <- list()
  matrices$Sigma <- Sigma
  matrices$Sigma_G <- Sigma_G
  matrices$E_Matrix <- E_Matrix
  matrices$Kin_Matrix <- Kin_Matrix
  return(matrices)
  
  ##### OPTIONAL TESTS TO RUN TO ENSURE MATRICES ARE CORRECT #####
  
  # # Test to make sure the cov matrix has the same correlations as the original cor matrix:
  # cor_Sigma <- cov2cor(Sigma)
  # cor_Sigma-cor
  # 
  # # Make sure the variances (h^2_pgs) are the same, too:
  # diag(Sigma) - pgs 
  # 
  # # ensure that the covariances are the same between Sigma and Sigma_G
  # cor_Sigma_G <- cov2cor(Sigma_G)
  # cor_Sigma_G - cor 
  # 
  # # The sum of all the matrices should have 1's on the diagonal
  # final_matrix <- E_Matrix + Sigma + Sigma_G
  # diag(final_matrix) - rep(1, nrow(final_matrix))
  # 
}

# General function to generate scores for Z, E_E, or E_G:
generate_single_component_score <- function(Sigma, Kin_Matrix) {
  kronecker_matrix <- kronecker(Sigma, Kin_Matrix)
  scores <- mvrnorm(mu = rep(0, ncol(Kin_Matrix)*ncol(Sigma)), Sigma = kronecker_matrix) # 1 x M*n vector
  return(matrix(nrow = ncol(Kin_Matrix), ncol = ncol(Sigma), data = scores))
}
# kronecker_matrix <- make.positive.definite(kronecker(Sigma, Kin_Matrix), tol = 1e-16)
# scores <- mvrnorm(mu = rep(0, ncol(Kin_Matrix)*ncol(Sigma)), Sigma = kronecker_matrix) # 1 x M*n vector
# scores <- rnorm(1, 0, sqrt(kronecker_matrix))


# There's probably a more efficient way to do this. But it works for now.
return_D_scores <- function(Z_scores, threshold) {
  D_scores <- matrix(0, nrow = nrow(Z_scores), ncol = ncol(Z_scores))
  for(j in 1:nrow(D_scores)){
    D_scores[j,] <- Z_scores[j,] > threshold # for each embryo, see if score[j] > threshold[j]
  }
  return(D_scores)
}


# Takes an input the 4 matrices generated by generate_matrices_for_sim
# In this list, the order is: Sigma, Sigma_G, E_Matrix, and Kin_Matrix

generate_total_scores <- function(Sigma, Sigma_G, E_Matrix, Kin_Matrix, threshold, N_embryos) {
  PGS_scores <- generate_single_component_score(Sigma, Kin_Matrix)
  E_G_scores <- generate_single_component_score(Sigma_G, Kin_Matrix)
  E_E_scores <- mvrnorm(n = N_embryos, mu = rep(0, M), Sigma = E_Matrix)
  Z_scores <- PGS_scores + E_G_scores + E_E_scores
  # Z_scores <- PGS_scores + E_E_scores
  D_scores <- return_D_scores(Z_scores, threshold)
  matrix_list <- list()
  matrix_list$PGS_scores <- PGS_scores
  matrix_list$E_G_scores <- E_G_scores
  matrix_list$E_E_scores <- E_E_scores
  matrix_list$Z_scores <- Z_scores
  matrix_list$D_scores <- D_scores
  return(matrix_list)
}

